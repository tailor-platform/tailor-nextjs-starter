// Code generated by graphql-codegen. DO NOT EDIT.

/* eslint-disable @typescript-eslint/naming-convention */
/* eslint-disable todo-comment/ticket-url */
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T,
> = { [_ in K]?: never };
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends " $fragmentName" | "__typename" ? T[P] : never;
    };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  Date: { input: unknown; output: string };
  DateTime: { input: unknown; output: string };
  FieldSet: { input: unknown; output: unknown };
  Map: { input: unknown; output: unknown };
  Time: { input: unknown; output: string };
  Uint32: { input: unknown; output: unknown };
  _Any: { input: unknown; output: unknown };
};

export const Action = {
  /** Can create */
  Create: "create",
  /** Can delete */
  Delete: "delete",
  /** Can get */
  Get: "get",
  /** Can list */
  List: "list",
  /** Can update */
  Update: "update",
} as const;

export type Action = (typeof Action)[keyof typeof Action];
export type AddRoleToUsersInput = {
  roles?: InputMaybe<Array<RoleInput>>;
  user?: InputMaybe<UserInput>;
};

/** TODO */
export type Condition = {
  IntEq?: Maybe<ConditionIntValue>;
  IntGe?: Maybe<ConditionIntValue>;
  IntGt?: Maybe<ConditionIntValue>;
  IntLe?: Maybe<ConditionIntValue>;
  IntLt?: Maybe<ConditionIntValue>;
  IntNeq?: Maybe<ConditionIntValue>;
  StrContains?: Maybe<ConditionStrValue>;
  StrEq?: Maybe<ConditionStrValue>;
  StrNeq?: Maybe<ConditionStrValue>;
  UUIDEq?: Maybe<ConditionIdValue>;
  UUIDNeq?: Maybe<ConditionIdValue>;
  id: Scalars["ID"]["output"];
};

export type ConditionIdValue = {
  key: Scalars["String"]["output"];
  value: Scalars["ID"]["output"];
};

export type ConditionIdValueInput = {
  key: Scalars["String"]["input"];
  value: Scalars["ID"]["input"];
};

export type ConditionInput = {
  IntEq?: InputMaybe<ConditionIntValueInput>;
  IntGe?: InputMaybe<ConditionIntValueInput>;
  IntGt?: InputMaybe<ConditionIntValueInput>;
  IntLe?: InputMaybe<ConditionIntValueInput>;
  IntLt?: InputMaybe<ConditionIntValueInput>;
  IntNeq?: InputMaybe<ConditionIntValueInput>;
  StrContains?: InputMaybe<ConditionStrValueInput>;
  StrEq?: InputMaybe<ConditionStrValueInput>;
  StrNeq?: InputMaybe<ConditionStrValueInput>;
  UUIDEq?: InputMaybe<ConditionIdValueInput>;
  UUIDIsSelf?: InputMaybe<Scalars["Boolean"]["input"]>;
  UUIDNeq?: InputMaybe<ConditionIdValueInput>;
};

export type ConditionIntValue = {
  key: Scalars["String"]["output"];
  value: Scalars["Int"]["output"];
};

export type ConditionIntValueInput = {
  key: Scalars["String"]["input"];
  value: Scalars["Int"]["input"];
};

export type ConditionStrValue = {
  key: Scalars["String"]["output"];
  value: Scalars["String"]["output"];
};

export type ConditionStrValueInput = {
  key: Scalars["String"]["input"];
  value: Scalars["String"]["input"];
};

export const ConditionValueTypes = {
  ValueInt: "ValueInt",
  ValueSelfUuid: "ValueSelfUUID",
  ValueString: "ValueString",
  ValueUuid: "ValueUUID",
} as const;

export type ConditionValueTypes =
  (typeof ConditionValueTypes)[keyof typeof ConditionValueTypes];
export type ContactQueryInput = {
  contactName?: InputMaybe<StringFilter>;
  emailAddress?: InputMaybe<StringFilter>;
  id?: InputMaybe<UuidFilter>;
  phoneNumber?: InputMaybe<StringFilter>;
};

/** Autogenerated input type of CreateGroup. */
export type CreateGroupInput = {
  baseRoleID?: InputMaybe<Scalars["ID"]["input"]>;
  code?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * id is optional.
   * id not id specified then generate new uuid
   */
  id?: InputMaybe<Scalars["ID"]["input"]>;
  name: Scalars["String"]["input"];
  /** If true then create BaseRole */
  newBaseRole?: Scalars["Boolean"]["input"];
  /** If true then create RepresentativeRole */
  newRepresentativeRole?: Scalars["Boolean"]["input"];
  /**
   * parent group id
   * if not id specified then parent id is assigned root group
   */
  parentId?: InputMaybe<Scalars["ID"]["input"]>;
  representativeRoleID?: InputMaybe<Scalars["ID"]["input"]>;
};

export type CreateOrganizationInput = {
  name: Scalars["String"]["input"];
};

export type CreatePolicyInput = {
  actions: Array<Scalars["String"]["input"]>;
  condition: ConditionInput;
  id?: InputMaybe<Scalars["ID"]["input"]>;
  passwordRule: Scalars["Int"]["input"];
  permit: Permit;
  resources: Array<Scalars["String"]["input"]>;
  roleID: Scalars["ID"]["input"];
  serviceID?: InputMaybe<Scalars["ID"]["input"]>;
};

export type CreateRoleClassInput = {
  id?: InputMaybe<Scalars["ID"]["input"]>;
  name: Scalars["String"]["input"];
};

export type CreateRoleInput = {
  id?: InputMaybe<Scalars["ID"]["input"]>;
  name: Scalars["String"]["input"];
  /** if not specified role class id then create new role class */
  roleClassID?: InputMaybe<Scalars["ID"]["input"]>;
};

export type CreateServiceInput = {
  name: Scalars["String"]["input"];
  url: Scalars["String"]["input"];
};

export type CreateUserInput = {
  displayName: Scalars["String"]["input"];
  groups?: InputMaybe<Array<GroupInput>>;
  id?: InputMaybe<Scalars["ID"]["input"]>;
  organizationID?: InputMaybe<Scalars["ID"]["input"]>;
  profile?: InputMaybe<CreateUserProfileInput>;
  roles?: InputMaybe<Array<RoleInput>>;
  secret: Scalars["String"]["input"];
  username: Scalars["String"]["input"];
};

export type CreateUserProfileInput = {
  birthday?: InputMaybe<Scalars["DateTime"]["input"]>;
  city?: InputMaybe<Scalars["String"]["input"]>;
  costCenter?: InputMaybe<Scalars["String"]["input"]>;
  countryCode?: InputMaybe<Scalars["String"]["input"]>;
  department?: InputMaybe<Scalars["String"]["input"]>;
  division?: InputMaybe<Scalars["String"]["input"]>;
  email?: InputMaybe<Scalars["String"]["input"]>;
  employeeCode?: InputMaybe<Scalars["String"]["input"]>;
  firstName?: InputMaybe<Scalars["String"]["input"]>;
  gender?: InputMaybe<Gender>;
  honorificPrefix?: InputMaybe<Scalars["String"]["input"]>;
  honorificSuffix?: InputMaybe<Scalars["String"]["input"]>;
  joinedAt?: InputMaybe<Scalars["DateTime"]["input"]>;
  lastName?: InputMaybe<Scalars["String"]["input"]>;
  leftAt?: InputMaybe<Scalars["DateTime"]["input"]>;
  locale?: InputMaybe<Scalars["String"]["input"]>;
  middleName?: InputMaybe<Scalars["String"]["input"]>;
  mobilePhone?: InputMaybe<Scalars["String"]["input"]>;
  nickName?: InputMaybe<Scalars["String"]["input"]>;
  preferredLanguage?: InputMaybe<Scalars["String"]["input"]>;
  primaryPhone?: InputMaybe<Scalars["String"]["input"]>;
  profileUrl?: InputMaybe<Scalars["String"]["input"]>;
  secondEmail?: InputMaybe<Scalars["String"]["input"]>;
  state?: InputMaybe<Scalars["String"]["input"]>;
  streetAddress?: InputMaybe<Scalars["String"]["input"]>;
  timezone?: InputMaybe<Scalars["String"]["input"]>;
  title?: InputMaybe<Scalars["String"]["input"]>;
  userTypeId?: InputMaybe<Scalars["ID"]["input"]>;
  zipCode?: InputMaybe<Scalars["String"]["input"]>;
};

export type CreateUserTypeInput = {
  id?: InputMaybe<Scalars["ID"]["input"]>;
  name: Scalars["String"]["input"];
};

/** CustomerAccount model */
export type CustomerAccount = {
  /** The account's name. */
  companyName?: Maybe<Scalars["String"]["output"]>;
  /** The lead's contact. */
  contact?: Maybe<CustomerAccountContact>;
  /**
   * Create time
   * @deprecated No longer supported
   */
  created?: Maybe<Scalars["DateTime"]["output"]>;
  /** created by */
  createdByID?: Maybe<Scalars["ID"]["output"]>;
  /** Document id */
  id: Scalars["ID"]["output"];
  /** The account's lead */
  lead?: Maybe<Lead>;
  /** The account lead ID. */
  leadID?: Maybe<Scalars["ID"]["output"]>;
  /**
   * Update time
   * @deprecated No longer supported
   */
  updated?: Maybe<Scalars["DateTime"]["output"]>;
  /** updated by */
  updatedByID?: Maybe<Scalars["ID"]["output"]>;
};

/** The lead's contact. */
export type CustomerAccountContact = {
  /** The lead's contact name. */
  contactName?: Maybe<Scalars["String"]["output"]>;
  /** The lead's contact email address. */
  emailAddress?: Maybe<Scalars["String"]["output"]>;
  /** The lead's contact phone number. */
  phoneNumber?: Maybe<Scalars["String"]["output"]>;
};

export type CustomerAccountContactInput = {
  /** The lead's contact name. */
  contactName?: InputMaybe<Scalars["String"]["input"]>;
  /** The lead's contact email address. */
  emailAddress?: InputMaybe<Scalars["String"]["input"]>;
  /** The lead's contact phone number. */
  phoneNumber?: InputMaybe<Scalars["String"]["input"]>;
};

/** CustomerAccount model(CreateInput) */
export type CustomerAccountCreateInput = {
  /** The account's name. */
  companyName?: InputMaybe<Scalars["String"]["input"]>;
  contact?: InputMaybe<CustomerAccountContactInput>;
  id?: InputMaybe<Scalars["ID"]["input"]>;
  /** The account lead ID. */
  leadID?: InputMaybe<Scalars["ID"]["input"]>;
};

export const CustomerAccountOrderFieldEnum = {
  CompanyName: "companyName",
} as const;

export type CustomerAccountOrderFieldEnum =
  (typeof CustomerAccountOrderFieldEnum)[keyof typeof CustomerAccountOrderFieldEnum];
export type CustomerAccountOrderInput = {
  direction?: InputMaybe<OrderDirectionEnum>;
  field: CustomerAccountOrderFieldEnum;
};

/** CustomerAccount model(Input) */
export type CustomerAccountQueryInput = {
  and?: InputMaybe<CustomerAccountQueryInput>;
  companyName?: InputMaybe<StringFilter>;
  contact?: InputMaybe<ContactQueryInput>;
  id?: InputMaybe<UuidFilter>;
  leadID?: InputMaybe<UuidFilter>;
  not?: InputMaybe<CustomerAccountQueryInput>;
  or?: InputMaybe<CustomerAccountQueryInput>;
};

/** CustomerAccount model(Result) */
export type CustomerAccountResult = {
  collection: Array<CustomerAccount>;
  from: Scalars["Int"]["output"];
  items: Scalars["Int"]["output"];
  size: Scalars["Int"]["output"];
  total: Scalars["Int"]["output"];
};

/** CustomerAccount model(UpdateInput) */
export type CustomerAccountUpdateInput = {
  /** The account's name. */
  companyName?: InputMaybe<Scalars["String"]["input"]>;
  contact?: InputMaybe<CustomerAccountContactInput>;
  /** The account lead ID. */
  leadID?: InputMaybe<Scalars["ID"]["input"]>;
};

export type DateBetweenFilter = {
  max?: InputMaybe<Scalars["Date"]["input"]>;
  min?: InputMaybe<Scalars["Date"]["input"]>;
};

export type DateFilter = {
  between?: InputMaybe<DateBetweenFilter>;
  eq?: InputMaybe<Scalars["Date"]["input"]>;
  gt?: InputMaybe<Scalars["Date"]["input"]>;
  gte?: InputMaybe<Scalars["Date"]["input"]>;
  in?: InputMaybe<Array<InputMaybe<Scalars["Date"]["input"]>>>;
  lt?: InputMaybe<Scalars["Date"]["input"]>;
  lte?: InputMaybe<Scalars["Date"]["input"]>;
  ne?: InputMaybe<Scalars["Date"]["input"]>;
  nin?: InputMaybe<Array<InputMaybe<Scalars["Date"]["input"]>>>;
};

/** Autogenerated filter type of DateTime to see if a value is between two other given values. */
export type DateTimeBetweenFilter = {
  max?: InputMaybe<Scalars["DateTime"]["input"]>;
  min?: InputMaybe<Scalars["DateTime"]["input"]>;
};

/** Autogenerated query input type of DateTime. */
export type DateTimeQueryInput = {
  /** x <= n && n <= y:  Between x and y. */
  between?: InputMaybe<DateTimeBetweenFilter>;
  /** equal */
  eq?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** grater than > */
  gt?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** grater than or equal to >= */
  gte?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** in: [x, y ….] */
  in?: InputMaybe<Array<Scalars["DateTime"]["input"]>>;
  /** less than < */
  lt?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** less than or equal to <= */
  lte?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** not equal */
  ne?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** not in: [x, y ….] */
  nin?: InputMaybe<Array<Scalars["DateTime"]["input"]>>;
};

export type DatetimeBetweenFilter = {
  max?: InputMaybe<Scalars["DateTime"]["input"]>;
  min?: InputMaybe<Scalars["DateTime"]["input"]>;
};

export type DatetimeFilter = {
  between?: InputMaybe<DatetimeBetweenFilter>;
  eq?: InputMaybe<Scalars["DateTime"]["input"]>;
  gt?: InputMaybe<Scalars["DateTime"]["input"]>;
  gte?: InputMaybe<Scalars["DateTime"]["input"]>;
  in?: InputMaybe<Array<InputMaybe<Scalars["DateTime"]["input"]>>>;
  lt?: InputMaybe<Scalars["DateTime"]["input"]>;
  lte?: InputMaybe<Scalars["DateTime"]["input"]>;
  ne?: InputMaybe<Scalars["DateTime"]["input"]>;
  nin?: InputMaybe<Array<InputMaybe<Scalars["DateTime"]["input"]>>>;
};

/** Engagement model */
export type Engagement = {
  /** The engagement account's ID. */
  accountID?: Maybe<Scalars["ID"]["output"]>;
  /**
   * Create time
   * @deprecated No longer supported
   */
  created?: Maybe<Scalars["DateTime"]["output"]>;
  /** created by */
  createdByID?: Maybe<Scalars["ID"]["output"]>;
  /** The engagement's direction. Possible values include: INBOUND, OUTBOUND, or OTHERS */
  direction?: Maybe<EngagementDirection>;
  /** The engagement's discussion. */
  discussion?: Maybe<Scalars["String"]["output"]>;
  /** The time at which the engagement started. */
  engagedDatetime?: Maybe<Scalars["DateTime"]["output"]>;
  /** The engagement type of the engagement. */
  engagementType?: Maybe<Scalars["String"]["output"]>;
  /** Document id */
  id: Scalars["ID"]["output"];
  /** The engagement lead's ID. */
  leadID?: Maybe<Scalars["ID"]["output"]>;
  /** The engagement's next action. */
  nextAction?: Maybe<Scalars["String"]["output"]>;
  /** The engagement's subject. */
  subject?: Maybe<Scalars["String"]["output"]>;
  /**
   * Update time
   * @deprecated No longer supported
   */
  updated?: Maybe<Scalars["DateTime"]["output"]>;
  /** updated by */
  updatedByID?: Maybe<Scalars["ID"]["output"]>;
};

/** Engagement model(CreateInput) */
export type EngagementCreateInput = {
  /** The engagement account's ID. */
  accountID?: InputMaybe<Scalars["ID"]["input"]>;
  /** The engagement's direction. Possible values include: INBOUND, OUTBOUND, or OTHERS */
  direction?: InputMaybe<EngagementDirection>;
  /** The engagement's discussion. */
  discussion?: InputMaybe<Scalars["String"]["input"]>;
  /** The time at which the engagement started. */
  engagedDatetime?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** The engagement type of the engagement. */
  engagementType?: InputMaybe<Scalars["String"]["input"]>;
  id?: InputMaybe<Scalars["ID"]["input"]>;
  /** The engagement lead's ID. */
  leadID?: InputMaybe<Scalars["ID"]["input"]>;
  /** The engagement's next action. */
  nextAction?: InputMaybe<Scalars["String"]["input"]>;
  /** The engagement's subject. */
  subject?: InputMaybe<Scalars["String"]["input"]>;
};

export const EngagementDirection = {
  Inbound: "INBOUND",
  Others: "OTHERS",
  Outbound: "OUTBOUND",
} as const;

export type EngagementDirection =
  (typeof EngagementDirection)[keyof typeof EngagementDirection];
export type EngagementDirectionEnumFilter = {
  eq?: InputMaybe<EngagementDirection>;
  in?: InputMaybe<Array<InputMaybe<EngagementDirection>>>;
  ne?: InputMaybe<EngagementDirection>;
  nin?: InputMaybe<Array<InputMaybe<EngagementDirection>>>;
};

export const EngagementOrderFieldEnum = {
  Direction: "direction",
  Discussion: "discussion",
  EngagedDatetime: "engagedDatetime",
  EngagementType: "engagementType",
  NextAction: "nextAction",
  Subject: "subject",
} as const;

export type EngagementOrderFieldEnum =
  (typeof EngagementOrderFieldEnum)[keyof typeof EngagementOrderFieldEnum];
export type EngagementOrderInput = {
  direction?: InputMaybe<OrderDirectionEnum>;
  field: EngagementOrderFieldEnum;
};

/** Engagement model(Input) */
export type EngagementQueryInput = {
  accountID?: InputMaybe<UuidFilter>;
  and?: InputMaybe<EngagementQueryInput>;
  direction?: InputMaybe<EngagementDirectionEnumFilter>;
  discussion?: InputMaybe<StringFilter>;
  engagedDatetime?: InputMaybe<DatetimeFilter>;
  engagementType?: InputMaybe<StringFilter>;
  id?: InputMaybe<UuidFilter>;
  leadID?: InputMaybe<UuidFilter>;
  nextAction?: InputMaybe<StringFilter>;
  not?: InputMaybe<EngagementQueryInput>;
  or?: InputMaybe<EngagementQueryInput>;
  subject?: InputMaybe<StringFilter>;
};

/** Engagement model(Result) */
export type EngagementResult = {
  collection: Array<Engagement>;
  from: Scalars["Int"]["output"];
  items: Scalars["Int"]["output"];
  size: Scalars["Int"]["output"];
  total: Scalars["Int"]["output"];
};

/** Engagement model(UpdateInput) */
export type EngagementUpdateInput = {
  /** The engagement account's ID. */
  accountID?: InputMaybe<Scalars["ID"]["input"]>;
  /** The engagement's direction. Possible values include: INBOUND, OUTBOUND, or OTHERS */
  direction?: InputMaybe<EngagementDirection>;
  /** The engagement's discussion. */
  discussion?: InputMaybe<Scalars["String"]["input"]>;
  /** The time at which the engagement started. */
  engagedDatetime?: InputMaybe<Scalars["DateTime"]["input"]>;
  /** The engagement type of the engagement. */
  engagementType?: InputMaybe<Scalars["String"]["input"]>;
  /** The engagement lead's ID. */
  leadID?: InputMaybe<Scalars["ID"]["input"]>;
  /** The engagement's next action. */
  nextAction?: InputMaybe<Scalars["String"]["input"]>;
  /** The engagement's subject. */
  subject?: InputMaybe<Scalars["String"]["input"]>;
};

/** Gender type based on ISO 5218. */
export const Gender = {
  /** female */
  Female: "Female",
  /** male */
  Male: "Male",
  /** not applicable */
  NotApplicable: "NotApplicable",
  /** not known */
  NotKnown: "NotKnown",
} as const;

export type Gender = (typeof Gender)[keyof typeof Gender];
/** A group on Tailor Platform. */
export type Group = {
  /** Base role of the group. */
  baseRole?: Maybe<Role>;
  /** Children of the group (id any). */
  children?: Maybe<GroupCollection>;
  /** Code of the group. */
  code?: Maybe<Scalars["String"]["output"]>;
  /** Timestamp when the group was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** ID of the group */
  id: Scalars["ID"]["output"];
  /** Returns TRUE if the group is a leaf (at level 0). */
  isLeaf: Scalars["Boolean"]["output"];
  /** Name of the group. */
  name: Scalars["String"]["output"];
  /** ID of the organization associated with the group. */
  organizationID: Scalars["ID"]["output"];
  /** Parent of the group (if any). */
  parent?: Maybe<Group>;
  /** Representative role of the group. */
  representativeRole?: Maybe<Role>;
  /** Timestamp when the group was last updated. */
  updatedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** List of the users associated with the group. */
  users?: Maybe<UserCollection>;
};

/** A group on Tailor Platform. */
export type GroupChildrenArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<GroupOrderInput>>>;
  query?: InputMaybe<GroupQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A group on Tailor Platform. */
export type GroupUsersArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<UserOrderInput>>>;
  query?: InputMaybe<UserQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A list of Group. */
export type GroupCollection = {
  /** A list of groups. */
  collection: Array<Group>;
  from: Scalars["Int"]["output"];
  size: Scalars["Int"]["output"];
  /** Information to aid in pagination. */
  total: Scalars["Int"]["output"];
};

/** Conditional filter input type of GroupQueryInput. */
export type GroupFilterConditionalInputType = {
  /** and condition */
  and?: InputMaybe<Array<InputMaybe<GroupQueryInput>>>;
  /** or condition */
  or?: InputMaybe<Array<InputMaybe<GroupQueryInput>>>;
};

/** Autogenerated input type of Group. */
export type GroupInput = {
  id: Scalars["ID"]["input"];
};

/** Autogenerated order enum type of Group. */
export const GroupOrderFieldEnum = {
  Code: "CODE",
  CreatedAt: "CREATED_AT",
  Name: "NAME",
  UpdatedAt: "UPDATED_AT",
} as const;

export type GroupOrderFieldEnum =
  (typeof GroupOrderFieldEnum)[keyof typeof GroupOrderFieldEnum];
/** Autogenerated order input type of Group. */
export type GroupOrderInput = {
  direction?: InputMaybe<OrderDirectionEnum>;
  field: GroupOrderFieldEnum;
};

/** Autogenerated query input type of Group. */
export type GroupQueryInput = {
  /** and condition */
  and?: InputMaybe<GroupQueryInput>;
  code?: InputMaybe<StringQueryInput>;
  createdAt?: InputMaybe<DateTimeQueryInput>;
  id?: InputMaybe<UuidQueryInput>;
  name?: InputMaybe<StringQueryInput>;
  /** or condition */
  or?: InputMaybe<GroupQueryInput>;
  organizationID?: InputMaybe<UuidQueryInput>;
  parentID?: InputMaybe<UuidQueryInput>;
  parentName?: InputMaybe<StringQueryInput>;
  updatedAt?: InputMaybe<DateTimeQueryInput>;
};

/** Autogenerated filter type of number to see if a value is between two other given values. */
export type IntBetweenFilter = {
  max?: InputMaybe<Scalars["Int"]["input"]>;
  min?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Autogenerated query input type of number. */
export type IntQueryInput = {
  /** x <= n && n <= y:  Between x and y. */
  between?: InputMaybe<IntBetweenFilter>;
  /** equal */
  eq?: InputMaybe<Scalars["Int"]["input"]>;
  /** grater than > */
  gt?: InputMaybe<Scalars["Int"]["input"]>;
  /** greater than or equal to >= */
  gte?: InputMaybe<Scalars["Int"]["input"]>;
  /** in: [x, y ….] */
  in?: InputMaybe<Array<Scalars["Int"]["input"]>>;
  /** less than < */
  lt?: InputMaybe<Scalars["Int"]["input"]>;
  /** less than or equal to <= */
  lte?: InputMaybe<Scalars["Int"]["input"]>;
  /** not equal */
  ne?: InputMaybe<Scalars["Int"]["input"]>;
  /** not in: [x, y ….] */
  nin?: InputMaybe<Array<Scalars["Int"]["input"]>>;
};

export type IntegerBetweenFilter = {
  max?: InputMaybe<Scalars["Int"]["input"]>;
  min?: InputMaybe<Scalars["Int"]["input"]>;
};

export type IntegerFilter = {
  between?: InputMaybe<IntegerBetweenFilter>;
  eq?: InputMaybe<Scalars["Int"]["input"]>;
  gt?: InputMaybe<Scalars["Int"]["input"]>;
  gte?: InputMaybe<Scalars["Int"]["input"]>;
  in?: InputMaybe<Array<InputMaybe<Scalars["Int"]["input"]>>>;
  lt?: InputMaybe<Scalars["Int"]["input"]>;
  lte?: InputMaybe<Scalars["Int"]["input"]>;
  ne?: InputMaybe<Scalars["Int"]["input"]>;
  nin?: InputMaybe<Array<InputMaybe<Scalars["Int"]["input"]>>>;
};

/** Lead model */
export type Lead = {
  /** The lead's company name. */
  companyName?: Maybe<Scalars["String"]["output"]>;
  /** The lead's contact. */
  contact?: Maybe<LeadContact>;
  /** The account id of the converted lead. */
  convertedAccountID?: Maybe<Scalars["ID"]["output"]>;
  /** When the lead was converted. */
  convertedDate?: Maybe<Scalars["Date"]["output"]>;
  /**
   * Create time
   * @deprecated No longer supported
   */
  created?: Maybe<Scalars["DateTime"]["output"]>;
  /** created by */
  createdByID?: Maybe<Scalars["ID"]["output"]>;
  /** The lead's deal amount. */
  dealAmount?: Maybe<Scalars["String"]["output"]>;
  /** The lead's engagement. */
  engagementID?: Maybe<Scalars["ID"]["output"]>;
  /** Document id */
  id: Scalars["ID"]["output"];
  /** The lead's source. */
  leadSource?: Maybe<Scalars["String"]["output"]>;
  /** The lead's sales stage. */
  stage?: Maybe<LeadStage>;
  /**
   * Update time
   * @deprecated No longer supported
   */
  updated?: Maybe<Scalars["DateTime"]["output"]>;
  /** updated by */
  updatedByID?: Maybe<Scalars["ID"]["output"]>;
};

/** The lead's contact. */
export type LeadContact = {
  /** The lead's contact name. */
  contactName?: Maybe<Scalars["String"]["output"]>;
  /** The lead's contact email address. */
  emailAddress?: Maybe<Scalars["String"]["output"]>;
  /** The lead's contact phone number. */
  phoneNumber?: Maybe<Scalars["String"]["output"]>;
};

export type LeadContactInput = {
  /** The lead's contact name. */
  contactName?: InputMaybe<Scalars["String"]["input"]>;
  /** The lead's contact email address. */
  emailAddress?: InputMaybe<Scalars["String"]["input"]>;
  /** The lead's contact phone number. */
  phoneNumber?: InputMaybe<Scalars["String"]["input"]>;
};

/** Lead model(CreateInput) */
export type LeadCreateInput = {
  /** The lead's company name. */
  companyName?: InputMaybe<Scalars["String"]["input"]>;
  contact?: InputMaybe<LeadContactInput>;
  /** The account id of the converted lead. */
  convertedAccountID?: InputMaybe<Scalars["ID"]["input"]>;
  /** When the lead was converted. */
  convertedDate?: InputMaybe<Scalars["Date"]["input"]>;
  /** The lead's deal amount. */
  dealAmount?: InputMaybe<Scalars["String"]["input"]>;
  /** The lead's engagement. */
  engagementID?: InputMaybe<Scalars["ID"]["input"]>;
  id?: InputMaybe<Scalars["ID"]["input"]>;
  /** The lead's source. */
  leadSource?: InputMaybe<Scalars["String"]["input"]>;
  /** The lead's sales stage. */
  stage?: InputMaybe<LeadStage>;
};

export const LeadOrderFieldEnum = {
  CompanyName: "companyName",
  ConvertedDate: "convertedDate",
  DealAmount: "dealAmount",
  LeadSource: "leadSource",
  Stage: "stage",
} as const;

export type LeadOrderFieldEnum =
  (typeof LeadOrderFieldEnum)[keyof typeof LeadOrderFieldEnum];
export type LeadOrderInput = {
  direction?: InputMaybe<OrderDirectionEnum>;
  field: LeadOrderFieldEnum;
};

/** Lead model(Input) */
export type LeadQueryInput = {
  and?: InputMaybe<LeadQueryInput>;
  companyName?: InputMaybe<StringFilter>;
  contact?: InputMaybe<ContactQueryInput>;
  convertedAccountID?: InputMaybe<UuidFilter>;
  convertedDate?: InputMaybe<DateFilter>;
  dealAmount?: InputMaybe<StringFilter>;
  engagementID?: InputMaybe<UuidFilter>;
  id?: InputMaybe<UuidFilter>;
  leadSource?: InputMaybe<StringFilter>;
  not?: InputMaybe<LeadQueryInput>;
  or?: InputMaybe<LeadQueryInput>;
  stage?: InputMaybe<LeadStageEnumFilter>;
};

/** Lead model(Result) */
export type LeadResult = {
  collection: Array<Lead>;
  from: Scalars["Int"]["output"];
  items: Scalars["Int"]["output"];
  size: Scalars["Int"]["output"];
  total: Scalars["Int"]["output"];
};

export const LeadStage = {
  Lost: "Lost",
  Open: "Open",
  Wip: "WIP",
  Won: "Won",
} as const;

export type LeadStage = (typeof LeadStage)[keyof typeof LeadStage];
export type LeadStageEnumFilter = {
  eq?: InputMaybe<LeadStage>;
  in?: InputMaybe<Array<InputMaybe<LeadStage>>>;
  ne?: InputMaybe<LeadStage>;
  nin?: InputMaybe<Array<InputMaybe<LeadStage>>>;
};

/** Lead model(UpdateInput) */
export type LeadUpdateInput = {
  /** The lead's company name. */
  companyName?: InputMaybe<Scalars["String"]["input"]>;
  contact?: InputMaybe<LeadContactInput>;
  /** The account id of the converted lead. */
  convertedAccountID?: InputMaybe<Scalars["ID"]["input"]>;
  /** When the lead was converted. */
  convertedDate?: InputMaybe<Scalars["Date"]["input"]>;
  /** The lead's deal amount. */
  dealAmount?: InputMaybe<Scalars["String"]["input"]>;
  /** The lead's engagement. */
  engagementID?: InputMaybe<Scalars["ID"]["input"]>;
  /** The lead's source. */
  leadSource?: InputMaybe<Scalars["String"]["input"]>;
  /** The lead's sales stage. */
  stage?: InputMaybe<LeadStage>;
};

export type LoginPayload = {
  /** token(JWT Token). */
  token: Scalars["String"]["output"];
  /** Successfully logged-in user. */
  user: User;
};

export type Mutation = {
  /**
   * Deprecated. Adds a role to a user.
   * @deprecated No longer supported
   */
  addRoleToUser?: Maybe<Role>;
  /**
   * Deprecated. Adds roles to multiple users.
   * @deprecated No longer supported
   */
  addRoleToUsers?: Maybe<Role>;
  addServiceToOrganization?: Maybe<Array<Service>>;
  /**
   * Deprecated: Adds a user to a group. Use updateUserGroup instead.
   * @deprecated Use updateUserGroup instead.
   */
  addUserToGroup?: Maybe<Group>;
  /**
   * Deprecated. Adds multiple roles to a user.
   * @deprecated No longer supported
   */
  addUserToRoles?: Maybe<User>;
  /** CustomerAccount model(Change) */
  changeCustomerAccount?: Maybe<Scalars["Boolean"]["output"]>;
  /** Engagement model(Change) */
  changeEngagement?: Maybe<Scalars["Boolean"]["output"]>;
  /** Lead model(Change) */
  changeLead?: Maybe<Scalars["Boolean"]["output"]>;
  /** Transaction model(Change) */
  changeTransaction?: Maybe<Scalars["Boolean"]["output"]>;
  convertAccount?: Maybe<Scalars["Boolean"]["output"]>;
  /** CustomerAccount model(Create) */
  createCustomerAccount?: Maybe<CustomerAccount>;
  /** Engagement model(Create) */
  createEngagement?: Maybe<Engagement>;
  /** Creates a new group. */
  createGroup?: Maybe<Group>;
  /** Lead model(Create) */
  createLead?: Maybe<Lead>;
  /** Creates a new organization with the given input data. */
  createOrganization?: Maybe<Organization>;
  /** Creates a new policy with the given input data. */
  createPolicy?: Maybe<Policy>;
  /** Creates a new role with the given input data. */
  createRole?: Maybe<Role>;
  /** Creates a new role class with the given input data. */
  createRoleClass?: Maybe<RoleClass>;
  createService?: Maybe<Service>;
  /** Transaction model(Create) */
  createTransaction?: Maybe<Transaction>;
  /** Create a user. */
  createUser?: Maybe<User>;
  createUserType?: Maybe<UserType>;
  /** Deactivate a user. */
  deactivateUser?: Maybe<Scalars["Boolean"]["output"]>;
  /** CustomerAccount model(Delete) */
  deleteCustomerAccount?: Maybe<Scalars["Boolean"]["output"]>;
  /** Engagement model(Delete) */
  deleteEngagement?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes a group by ID. */
  deleteGroup?: Maybe<Scalars["Boolean"]["output"]>;
  /** Lead model(Delete) */
  deleteLead?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes the organization with the specified ID. */
  deleteOrganization?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes the policy with the given ID. */
  deletePolicy?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes a role with the given ID. */
  deleteRole?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing role class with the given input data. */
  deleteRoleClass?: Maybe<Scalars["Boolean"]["output"]>;
  /**
   * Deprecated. Deletes a role from a user.
   * @deprecated No longer supported
   */
  deleteRoleFromUser?: Maybe<Role>;
  deleteService?: Maybe<Scalars["Boolean"]["output"]>;
  /** Transaction model(Delete) */
  deleteTransaction?: Maybe<Scalars["Boolean"]["output"]>;
  /** Delete a user. */
  deleteUser?: Maybe<Scalars["Boolean"]["output"]>;
  /**
   * Deprecated: Deletes a user from a group. Use updateUserGroup instead.
   * @deprecated Use updateUserGroup instead.
   */
  deleteUserFromGroup?: Maybe<Group>;
  deleteUserType?: Maybe<Scalars["Boolean"]["output"]>;
  /**
   * Returns JWT token and user information after successful login mutation.
   * ### Error message
   * - LoginFail: Login failed (either ID and/or Password is invalid).
   */
  login?: Maybe<LoginPayload>;
  /** Logout. Returns true if logout successfully. */
  logout: Scalars["Boolean"]["output"];
  removeServiceFromOrganization?: Maybe<Array<Service>>;
  /** Password reset. */
  resetPassword?: Maybe<Scalars["Boolean"]["output"]>;
  /** Password reset (token method, no authentication required). */
  resetPasswordByToken?: Maybe<Scalars["Boolean"]["output"]>;
  /** Generate a token for password reset and send it via email (no authentication required) */
  sendMailPasswordResetURL?: Maybe<Scalars["Boolean"]["output"]>;
  /** CustomerAccount model(Update) */
  updateCustomerAccount?: Maybe<CustomerAccount>;
  /** Engagement model(Update) */
  updateEngagement?: Maybe<Engagement>;
  /** Updates an existing group. */
  updateGroup?: Maybe<Group>;
  /** Lead model(Update) */
  updateLead?: Maybe<Lead>;
  /** Updates an existing organization with the given input data. */
  updateOrganization?: Maybe<Organization>;
  /**
   * Update a password. You need to be authenticated to use this API.
   *
   * ## Response
   * |  returns  |  result  |
   * | ---- | ---- |
   * |  true  |  success  |
   * |  false  |  failure  |
   *
   * ## Error
   * |  error code  | result |
   * | ---- | ---- |
   * |  UserPasswordUpdateFail  |  Password update failed.  |
   */
  updatePassword?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates an existing policy with the given input data. */
  updatePolicy?: Maybe<Policy>;
  /** Updates an existing role with the given input data. */
  updateRole?: Maybe<Role>;
  /** Updates an existing role class with the given input data. */
  updateRoleClass?: Maybe<RoleClass>;
  updateService?: Maybe<Service>;
  /** Transaction model(Update) */
  updateTransaction?: Maybe<Transaction>;
  /** Update user information. */
  updateUser?: Maybe<User>;
  /** Updates user group relationships by adding or deleting users from a group. */
  updateUserGroup?: Maybe<UpdateUserGroupResult>;
  /** Updates the roles of multiple users. */
  updateUserRole?: Maybe<UpdateUserRoleResult>;
  updateUserType?: Maybe<UserType>;
};

export type MutationAddRoleToUserArgs = {
  roleId: Scalars["ID"]["input"];
  userId: Scalars["ID"]["input"];
};

export type MutationAddRoleToUsersArgs = {
  roleId: Scalars["ID"]["input"];
  userIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

export type MutationAddServiceToOrganizationArgs = {
  organizationID: Scalars["ID"]["input"];
  serviceID?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

export type MutationAddUserToGroupArgs = {
  input?: InputMaybe<UserGroupInput>;
};

export type MutationAddUserToRolesArgs = {
  roleIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  userId: Scalars["ID"]["input"];
};

export type MutationChangeCustomerAccountArgs = {
  delete?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
  id: Scalars["ID"]["input"];
  read?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
  update?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
};

export type MutationChangeEngagementArgs = {
  delete?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
  id: Scalars["ID"]["input"];
  read?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
  update?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
};

export type MutationChangeLeadArgs = {
  delete?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
  id: Scalars["ID"]["input"];
  read?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
  update?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
};

export type MutationChangeTransactionArgs = {
  delete?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
  id: Scalars["ID"]["input"];
  read?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
  update?: InputMaybe<Array<InputMaybe<PermissionItemInput>>>;
};

export type MutationConvertAccountArgs = {
  companyName: Scalars["String"]["input"];
  contactName?: InputMaybe<Scalars["String"]["input"]>;
  emailAddress?: InputMaybe<Scalars["String"]["input"]>;
  leadID: Scalars["ID"]["input"];
  phoneNumber?: InputMaybe<Scalars["String"]["input"]>;
};

export type MutationCreateCustomerAccountArgs = {
  id?: InputMaybe<Scalars["ID"]["input"]>;
  input?: InputMaybe<CustomerAccountCreateInput>;
};

export type MutationCreateEngagementArgs = {
  id?: InputMaybe<Scalars["ID"]["input"]>;
  input?: InputMaybe<EngagementCreateInput>;
};

export type MutationCreateGroupArgs = {
  input?: InputMaybe<CreateGroupInput>;
};

export type MutationCreateLeadArgs = {
  id?: InputMaybe<Scalars["ID"]["input"]>;
  input?: InputMaybe<LeadCreateInput>;
};

export type MutationCreateOrganizationArgs = {
  input: CreateOrganizationInput;
};

export type MutationCreatePolicyArgs = {
  input?: InputMaybe<CreatePolicyInput>;
};

export type MutationCreateRoleArgs = {
  input?: InputMaybe<CreateRoleInput>;
};

export type MutationCreateRoleClassArgs = {
  input?: InputMaybe<CreateRoleClassInput>;
};

export type MutationCreateServiceArgs = {
  input: CreateServiceInput;
};

export type MutationCreateTransactionArgs = {
  id?: InputMaybe<Scalars["ID"]["input"]>;
  input?: InputMaybe<TransactionCreateInput>;
};

export type MutationCreateUserArgs = {
  input: CreateUserInput;
};

export type MutationCreateUserTypeArgs = {
  input: CreateUserTypeInput;
};

export type MutationDeactivateUserArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeleteCustomerAccountArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeleteEngagementArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeleteGroupArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeleteLeadArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeleteOrganizationArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeletePolicyArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeleteRoleArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeleteRoleClassArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeleteRoleFromUserArgs = {
  input?: InputMaybe<UserRoleInput>;
};

export type MutationDeleteServiceArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeleteTransactionArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeleteUserArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationDeleteUserFromGroupArgs = {
  input?: InputMaybe<UserGroupInput>;
};

export type MutationDeleteUserTypeArgs = {
  id: Scalars["ID"]["input"];
};

export type MutationLoginArgs = {
  id: Scalars["String"]["input"];
  orgKey: Scalars["String"]["input"];
  password: Scalars["String"]["input"];
};

export type MutationRemoveServiceFromOrganizationArgs = {
  organizationID: Scalars["ID"]["input"];
  serviceID?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

export type MutationResetPasswordArgs = {
  id: Scalars["ID"]["input"];
  password: Scalars["String"]["input"];
};

export type MutationResetPasswordByTokenArgs = {
  orgKey: Scalars["String"]["input"];
  password: Scalars["String"]["input"];
  token: Scalars["ID"]["input"];
};

export type MutationSendMailPasswordResetUrlArgs = {
  appName: Scalars["String"]["input"];
  contactForm: Scalars["String"]["input"];
  email: Scalars["String"]["input"];
  isInitial: Scalars["Boolean"]["input"];
  orgKey: Scalars["String"]["input"];
};

export type MutationUpdateCustomerAccountArgs = {
  id: Scalars["ID"]["input"];
  input?: InputMaybe<CustomerAccountUpdateInput>;
};

export type MutationUpdateEngagementArgs = {
  id: Scalars["ID"]["input"];
  input?: InputMaybe<EngagementUpdateInput>;
};

export type MutationUpdateGroupArgs = {
  input?: InputMaybe<UpdateGroupInput>;
};

export type MutationUpdateLeadArgs = {
  id: Scalars["ID"]["input"];
  input?: InputMaybe<LeadUpdateInput>;
};

export type MutationUpdateOrganizationArgs = {
  input: UpdateOrganizationInput;
};

export type MutationUpdatePasswordArgs = {
  newPassword: Scalars["String"]["input"];
  oldPassword: Scalars["String"]["input"];
};

export type MutationUpdatePolicyArgs = {
  input?: InputMaybe<UpdatePolicyInput>;
};

export type MutationUpdateRoleArgs = {
  input?: InputMaybe<UpdateRoleInput>;
};

export type MutationUpdateRoleClassArgs = {
  input?: InputMaybe<UpdateRoleClassInput>;
};

export type MutationUpdateServiceArgs = {
  input: UpdateServiceInput;
};

export type MutationUpdateTransactionArgs = {
  id: Scalars["ID"]["input"];
  input?: InputMaybe<TransactionUpdateInput>;
};

export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};

export type MutationUpdateUserGroupArgs = {
  adds?: InputMaybe<Array<UserGroupAddInput>>;
  deletes?: InputMaybe<Array<UserGroupDeleteInput>>;
};

export type MutationUpdateUserRoleArgs = {
  adds?: InputMaybe<Array<UserRoleAddInput>>;
  deletes?: InputMaybe<Array<UserRoleDeleteInput>>;
};

export type MutationUpdateUserTypeArgs = {
  input: UpdateUserTypeInput;
};

export const OrderDirectionEnum = {
  Asc: "Asc",
  Desc: "Desc",
} as const;

export type OrderDirectionEnum =
  (typeof OrderDirectionEnum)[keyof typeof OrderDirectionEnum];
/** An organization on Tailor Platform. */
export type Organization = {
  /** Timestamp when the organization was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** ID of the organization. */
  id: Scalars["ID"]["output"];
  /** Name of the organization. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** Highest level of group in the organization. */
  rootGroup?: Maybe<Group>;
  /** Timestamp when the organization was last updated. */
  updatedAt?: Maybe<Scalars["DateTime"]["output"]>;
};

/** A collection of Organization. */
export type OrganizationCollection = {
  /** A list of organizations */
  collection: Array<Organization>;
  from: Scalars["Int"]["output"];
  size: Scalars["Int"]["output"];
  /** Information to aid in pagination. */
  total: Scalars["Int"]["output"];
};

/** Autogenerated conditional filter input type of OrganizationQueryInput. */
export type OrganizationFilterConditionalInputType = {
  /** and condition */
  and?: InputMaybe<Array<InputMaybe<OrganizationQueryInput>>>;
  /** or condition */
  or?: InputMaybe<Array<InputMaybe<OrganizationQueryInput>>>;
};

export const OrganizationOrderFieldEnum = {
  CreatedAt: "CREATED_AT",
  UpdatedAt: "UPDATED_AT",
} as const;

export type OrganizationOrderFieldEnum =
  (typeof OrganizationOrderFieldEnum)[keyof typeof OrganizationOrderFieldEnum];
export type OrganizationOrderInput = {
  direction?: InputMaybe<OrderDirectionEnum>;
  field: OrganizationOrderFieldEnum;
};

/** Autogenerated query input type of Organization. */
export type OrganizationQueryInput = {
  /** and condition */
  and?: InputMaybe<OrganizationQueryInput>;
  createdAt?: InputMaybe<DateTimeQueryInput>;
  deletedAt?: InputMaybe<DateTimeQueryInput>;
  name?: InputMaybe<StringQueryInput>;
  /** or condition */
  or?: InputMaybe<OrganizationQueryInput>;
  updatedAt?: InputMaybe<DateTimeQueryInput>;
};

export type Permission = {
  id?: Maybe<Scalars["ID"]["output"]>;
  permit?: Maybe<PermitEnum>;
};

export type PermissionItem = {
  delete?: Maybe<Array<Maybe<Permission>>>;
  read?: Maybe<Array<Maybe<Permission>>>;
  update?: Maybe<Array<Maybe<Permission>>>;
};

export type PermissionItemInput = {
  id?: InputMaybe<Scalars["ID"]["input"]>;
  permit?: InputMaybe<PermitEnum>;
};

/** TODO */
export const Permit = {
  /** Allow */
  Allow: "allow",
  /** Deny */
  Deny: "deny",
  /** Skip */
  Skip: "skip",
} as const;

export type Permit = (typeof Permit)[keyof typeof Permit];
export const PermitEnum = {
  Allow: "allow",
  Deny: "deny",
} as const;

export type PermitEnum = (typeof PermitEnum)[keyof typeof PermitEnum];
export type PermitQueryInput = {
  IsEmpty?: InputMaybe<Scalars["Boolean"]["input"]>;
  IsNotEmpty?: InputMaybe<Scalars["Boolean"]["input"]>;
  eq?: InputMaybe<Permit>;
  ne?: InputMaybe<Permit>;
};

/** A Policy is a collection of combinations of e.g, roles. */
export type Policy = {
  /** Actions assigned to the policy. */
  actions?: Maybe<Array<Scalars["String"]["output"]>>;
  /** Condition assigned to the policy. */
  condition?: Maybe<Condition>;
  /** Timestamp when the policy was created. */
  createdAt: Scalars["DateTime"]["output"];
  id: Scalars["ID"]["output"];
  /** Password rule assigned to the policy. */
  passwordRule?: Maybe<Scalars["Int"]["output"]>;
  /** Permit assigned to the policy. */
  permit: Permit;
  /** Resources assigned to the policy. */
  resources?: Maybe<Array<Scalars["String"]["output"]>>;
  /** Roles assigned to the policy. */
  roles?: Maybe<Array<Role>>;
  /** Service assigned to the policy. */
  service?: Maybe<Service>;
  /** Timestamp when the policy was last updated. */
  updatedAt?: Maybe<Scalars["DateTime"]["output"]>;
};

/** A list of Policy. */
export type PolicyCollection = {
  /** A list of policies. */
  collection: Array<Policy>;
  from: Scalars["Int"]["output"];
  size: Scalars["Int"]["output"];
  /** Information to aid in pagination. */
  total: Scalars["Int"]["output"];
};

export const PolicyOrderFieldEnum = {
  CreatedAt: "CREATED_AT",
  Permit: "PERMIT",
  UpdatedAt: "UPDATED_AT",
} as const;

export type PolicyOrderFieldEnum =
  (typeof PolicyOrderFieldEnum)[keyof typeof PolicyOrderFieldEnum];
export type PolicyOrderInput = {
  direction?: InputMaybe<OrderDirectionEnum>;
  field: PolicyOrderFieldEnum;
};

export type PolicyQueryInput = {
  and?: InputMaybe<PolicyQueryInput>;
  or?: InputMaybe<PolicyQueryInput>;
  passwordRule?: InputMaybe<IntQueryInput>;
  permit?: InputMaybe<PermitQueryInput>;
};

export type Query = {
  /** SDL */
  _service: _Service;
  /** CustomerAccount model(GetOne) */
  customerAccount?: Maybe<CustomerAccount>;
  /** CustomerAccount model(Permission) */
  customerAccountPermission?: Maybe<PermissionItem>;
  /** CustomerAccount model(GetList) */
  customerAccounts?: Maybe<CustomerAccountResult>;
  /** Engagement model(GetOne) */
  engagement?: Maybe<Engagement>;
  /** Engagement model(Permission) */
  engagementPermission?: Maybe<PermissionItem>;
  /** Engagement model(GetList) */
  engagements?: Maybe<EngagementResult>;
  /** Find a group. */
  group?: Maybe<Group>;
  /** Get a list of groups. */
  groups?: Maybe<GroupCollection>;
  /** Lead model(GetOne) */
  lead?: Maybe<Lead>;
  /** Lead model(Permission) */
  leadPermission?: Maybe<PermissionItem>;
  /** Lead model(GetList) */
  leads?: Maybe<LeadResult>;
  /** Get the current logged-in user information. */
  me?: Maybe<User>;
  /** Get an organization information. */
  organization?: Maybe<Organization>;
  /** List organizations' information. */
  organizations?: Maybe<OrganizationCollection>;
  /** Get a list of groups. */
  policies?: Maybe<PolicyCollection>;
  /** Find a group. */
  policy?: Maybe<Policy>;
  /** Get a user. */
  profile?: Maybe<UserProfile>;
  /**
   * List of users using UserProfile
   * - If UserProfile is set, you can get a list (search and sort by profile items).
   * - If UserProfile is no set, you can't get user profile information from this API.
   */
  profiles?: Maybe<UserProfileCollection>;
  /** Get a role. */
  role?: Maybe<Role>;
  /** List roles. */
  roles?: Maybe<RoleCollection>;
  /** Get a service */
  service?: Maybe<Service>;
  /** List services */
  services?: Maybe<ServiceCollection>;
  /** Transaction model(GetOne) */
  transaction?: Maybe<Transaction>;
  /** Transaction model(Permission) */
  transactionPermission?: Maybe<PermissionItem>;
  /** Transaction model(GetList) */
  transactions?: Maybe<TransactionResult>;
  /** Get User - Retrieve a single user specified by ID. It requires user/get Policy. */
  user?: Maybe<User>;
  userTypes?: Maybe<Array<UserType>>;
  /** User List - Search by profile item using filterProfile. */
  users?: Maybe<UserCollection>;
};

export type QueryCustomerAccountArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryCustomerAccountPermissionArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryCustomerAccountsArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<CustomerAccountOrderInput>>>;
  query?: InputMaybe<CustomerAccountQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

export type QueryEngagementArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryEngagementPermissionArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryEngagementsArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<EngagementOrderInput>>>;
  query?: InputMaybe<EngagementQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

export type QueryGroupArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryGroupsArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<GroupOrderInput>>>;
  query?: InputMaybe<GroupQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

export type QueryLeadArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryLeadPermissionArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryLeadsArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<LeadOrderInput>>>;
  query?: InputMaybe<LeadQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

export type QueryOrganizationArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryOrganizationsArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<OrganizationOrderInput>>>;
  query?: InputMaybe<OrganizationQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

export type QueryPoliciesArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<PolicyOrderInput>>>;
  query?: InputMaybe<PolicyQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

export type QueryPolicyArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryProfileArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryProfilesArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<UserProfileOrderInput>>>;
  query?: InputMaybe<UserProfileQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

export type QueryRoleArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryRolesArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<RoleOrderInput>>>;
  query?: InputMaybe<RoleQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

export type QueryServiceArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryServicesArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<ServiceOrderInput>>>;
  query?: InputMaybe<ServiceQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

export type QueryTransactionArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryTransactionPermissionArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryTransactionsArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<TransactionOrderInput>>>;
  query?: InputMaybe<TransactionQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

export type QueryUserArgs = {
  id: Scalars["ID"]["input"];
};

export type QueryUsersArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<UserOrderInput>>>;
  query?: InputMaybe<UserQueryInput>;
  queryProfile?: InputMaybe<UserProfileQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

export const Resource = {
  /** A group */
  Group: "group",
  /** An organization */
  Organization: "organization",
  /** A policy */
  Policy: "policy",
  /** A role */
  Role: "role",
  /** A service */
  Service: "service",
  /** A user */
  User: "user",
} as const;

export type Resource = (typeof Resource)[keyof typeof Resource];
/** You can use a Role to control user access to your data. TODO - Need more explanation for User/Role/Group. */
export type Role = {
  /** Timestamp when the role was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** ID of the role. */
  id: Scalars["ID"]["output"];
  /** Name of the role. */
  name: Scalars["String"]["output"];
  /** ID of the organization associated with the role. */
  organizationID: Scalars["ID"]["output"];
  /** A list of policies associated with the role. */
  policies?: Maybe<Array<Policy>>;
  /** Roleclass. */
  roleClass: RoleClass;
  /** Timestamp when the role was last updated. */
  updatedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** A list of users associated with the role. */
  users: UserCollection;
};

/** You can use a Role to control user access to your data. TODO - Need more explanation for User/Role/Group. */
export type RoleUsersArgs = {
  from?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<Array<InputMaybe<UserOrderInput>>>;
  query?: InputMaybe<UserQueryInput>;
  queryProfile?: InputMaybe<UserProfileQueryInput>;
  size?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Attributes of Role. */
export type RoleClass = {
  /** ID of the RoleClass. */
  id: Scalars["ID"]["output"];
  /** Name of the RoleClass. */
  name?: Maybe<Scalars["String"]["output"]>;
};

/** A collection of RoleClass. */
export type RoleClassCollection = {
  /** Information to aid in pagination. */
  collection?: Maybe<Array<Maybe<RoleClass>>>;
  from?: Maybe<Scalars["Int"]["output"]>;
  size?: Maybe<Scalars["Int"]["output"]>;
  /** Information to aid in pagination. */
  total?: Maybe<Scalars["Int"]["output"]>;
};

export type RoleClassFilterConditionalInputType = {
  /** and condition */
  and?: InputMaybe<Array<InputMaybe<RoleClassQueryInput>>>;
  /** or condition */
  or?: InputMaybe<Array<InputMaybe<RoleClassQueryInput>>>;
};

export type RoleClassQueryInput = {
  /** and condition */
  and?: InputMaybe<RoleClassQueryInput>;
  createdAt?: InputMaybe<DateTimeQueryInput>;
  name?: InputMaybe<StringQueryInput>;
  /** or condition */
  or?: InputMaybe<RoleClassQueryInput>;
  organizationID?: InputMaybe<UuidQueryInput>;
  updatedAt?: InputMaybe<DateTimeQueryInput>;
};

/** A collection of Role. */
export type RoleCollection = {
  /** Information to aid in pagination. */
  collection: Array<Role>;
  from: Scalars["Int"]["output"];
  size: Scalars["Int"]["output"];
  /** Information to aid in pagination. */
  total: Scalars["Int"]["output"];
};

export type RoleFilterConditionalInputType = {
  /** and condition */
  and?: InputMaybe<Array<InputMaybe<RoleQueryInput>>>;
  /** or condition */
  or?: InputMaybe<Array<InputMaybe<RoleQueryInput>>>;
};

export type RoleInput = {
  id: Scalars["ID"]["input"];
};

export const RoleOrderFieldEnum = {
  CreatedAt: "CREATED_AT",
  Name: "NAME",
  UpdatedAt: "UPDATED_AT",
} as const;

export type RoleOrderFieldEnum =
  (typeof RoleOrderFieldEnum)[keyof typeof RoleOrderFieldEnum];
export type RoleOrderInput = {
  direction?: InputMaybe<OrderDirectionEnum>;
  field: RoleOrderFieldEnum;
};

export type RoleQueryInput = {
  id?: InputMaybe<UuidQueryInput>;
  name?: InputMaybe<StringQueryInput>;
  organizationID?: InputMaybe<UuidQueryInput>;
  roleClassID?: InputMaybe<UuidQueryInput>;
};

export type Service = {
  createdAt: Scalars["DateTime"]["output"];
  id: Scalars["ID"]["output"];
  name?: Maybe<Scalars["String"]["output"]>;
  updatedAt?: Maybe<Scalars["DateTime"]["output"]>;
  url?: Maybe<Scalars["String"]["output"]>;
};

/** A collection to a list of items. */
export type ServiceCollection = {
  /** Information to aid in pagination. */
  collection: Array<Service>;
  from: Scalars["Int"]["output"];
  size: Scalars["Int"]["output"];
  /** Information to aid in pagination. */
  total: Scalars["Int"]["output"];
};

export type ServiceFilterConditionalInputType = {
  /** and condition */
  and?: InputMaybe<Array<InputMaybe<ServiceQueryInput>>>;
  /** or condition */
  or?: InputMaybe<Array<InputMaybe<ServiceQueryInput>>>;
};

export const ServiceOrderFieldEnum = {
  CreatedAt: "CREATED_AT",
  Name: "NAME",
  UpdatedAt: "UPDATED_AT",
  Url: "URL",
} as const;

export type ServiceOrderFieldEnum =
  (typeof ServiceOrderFieldEnum)[keyof typeof ServiceOrderFieldEnum];
export type ServiceOrderInput = {
  direction: OrderDirectionEnum;
  field: ServiceOrderFieldEnum;
};

export type ServiceQueryInput = {
  /** and condition */
  and?: InputMaybe<ServiceQueryInput>;
  createdAt?: InputMaybe<DateTimeQueryInput>;
  name?: InputMaybe<StringQueryInput>;
  /** or condition */
  or?: InputMaybe<ServiceQueryInput>;
  updatedAt?: InputMaybe<DateTimeQueryInput>;
  url?: InputMaybe<StringQueryInput>;
};

export type StringFilter = {
  contains?: InputMaybe<Scalars["String"]["input"]>;
  eq?: InputMaybe<Scalars["String"]["input"]>;
  in?: InputMaybe<Array<InputMaybe<Scalars["String"]["input"]>>>;
  ne?: InputMaybe<Scalars["String"]["input"]>;
  nin?: InputMaybe<Array<InputMaybe<Scalars["String"]["input"]>>>;
  regex?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated query input type of string. */
export type StringQueryInput = {
  contains?: InputMaybe<Scalars["String"]["input"]>;
  /** equal */
  eq?: InputMaybe<Scalars["String"]["input"]>;
  /** in: [x, y ….] */
  in?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** not equal */
  ne?: InputMaybe<Scalars["String"]["input"]>;
  /** not in: [x, y ….] */
  nin?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

export type TimeBetweenFilter = {
  max?: InputMaybe<Scalars["Time"]["input"]>;
  min?: InputMaybe<Scalars["Time"]["input"]>;
};

export type TimeFilter = {
  between?: InputMaybe<TimeBetweenFilter>;
  eq?: InputMaybe<Scalars["Time"]["input"]>;
  gt?: InputMaybe<Scalars["Time"]["input"]>;
  gte?: InputMaybe<Scalars["Time"]["input"]>;
  in?: InputMaybe<Array<InputMaybe<Scalars["Time"]["input"]>>>;
  lt?: InputMaybe<Scalars["Time"]["input"]>;
  lte?: InputMaybe<Scalars["Time"]["input"]>;
  ne?: InputMaybe<Scalars["Time"]["input"]>;
  nin?: InputMaybe<Array<InputMaybe<Scalars["Time"]["input"]>>>;
};

/** Transaction model */
export type Transaction = {
  /** The transaction's account ID. */
  accountID: Scalars["ID"]["output"];
  /**
   * Create time
   * @deprecated No longer supported
   */
  created?: Maybe<Scalars["DateTime"]["output"]>;
  /** created by */
  createdByID?: Maybe<Scalars["ID"]["output"]>;
  /** Document id */
  id: Scalars["ID"]["output"];
  /** The transaction amount. */
  transactionAmt: Scalars["Int"]["output"];
  /** The transaction date. */
  transactionDate: Scalars["Date"]["output"];
  /** The transaction method. */
  transactionMethod?: Maybe<Scalars["String"]["output"]>;
  /** The transaction type. */
  transactionType?: Maybe<Scalars["String"]["output"]>;
  /**
   * Update time
   * @deprecated No longer supported
   */
  updated?: Maybe<Scalars["DateTime"]["output"]>;
  /** updated by */
  updatedByID?: Maybe<Scalars["ID"]["output"]>;
};

/** Transaction model(CreateInput) */
export type TransactionCreateInput = {
  /** The transaction's account ID. */
  accountID: Scalars["ID"]["input"];
  id?: InputMaybe<Scalars["ID"]["input"]>;
  /** The transaction amount. */
  transactionAmt: Scalars["Int"]["input"];
  /** The transaction date. */
  transactionDate: Scalars["Date"]["input"];
  /** The transaction method. */
  transactionMethod?: InputMaybe<Scalars["String"]["input"]>;
  /** The transaction type. */
  transactionType?: InputMaybe<Scalars["String"]["input"]>;
};

export const TransactionOrderFieldEnum = {
  TransactionAmt: "transactionAmt",
  TransactionDate: "transactionDate",
  TransactionMethod: "transactionMethod",
  TransactionType: "transactionType",
} as const;

export type TransactionOrderFieldEnum =
  (typeof TransactionOrderFieldEnum)[keyof typeof TransactionOrderFieldEnum];
export type TransactionOrderInput = {
  direction?: InputMaybe<OrderDirectionEnum>;
  field: TransactionOrderFieldEnum;
};

/** Transaction model(Input) */
export type TransactionQueryInput = {
  accountID?: InputMaybe<UuidFilter>;
  and?: InputMaybe<TransactionQueryInput>;
  id?: InputMaybe<UuidFilter>;
  not?: InputMaybe<TransactionQueryInput>;
  or?: InputMaybe<TransactionQueryInput>;
  transactionAmt?: InputMaybe<IntegerFilter>;
  transactionDate?: InputMaybe<DateFilter>;
  transactionMethod?: InputMaybe<StringFilter>;
  transactionType?: InputMaybe<StringFilter>;
};

/** Transaction model(Result) */
export type TransactionResult = {
  collection: Array<Transaction>;
  from: Scalars["Int"]["output"];
  items: Scalars["Int"]["output"];
  size: Scalars["Int"]["output"];
  total: Scalars["Int"]["output"];
};

/** Transaction model(UpdateInput) */
export type TransactionUpdateInput = {
  /** The transaction's account ID. */
  accountID?: InputMaybe<Scalars["ID"]["input"]>;
  /** The transaction amount. */
  transactionAmt?: InputMaybe<Scalars["Int"]["input"]>;
  /** The transaction date. */
  transactionDate?: InputMaybe<Scalars["Date"]["input"]>;
  /** The transaction method. */
  transactionMethod?: InputMaybe<Scalars["String"]["input"]>;
  /** The transaction type. */
  transactionType?: InputMaybe<Scalars["String"]["input"]>;
};

export type UuidFilter = {
  eq?: InputMaybe<Scalars["ID"]["input"]>;
  in?: InputMaybe<Array<InputMaybe<Scalars["ID"]["input"]>>>;
  ne?: InputMaybe<Scalars["ID"]["input"]>;
  nin?: InputMaybe<Array<InputMaybe<Scalars["ID"]["input"]>>>;
};

/** Autogenerated query input type of UUID. */
export type UuidQueryInput = {
  /** equal */
  eq?: InputMaybe<Scalars["ID"]["input"]>;
  /** in: [x, y ….] */
  in?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** not equal */
  ne?: InputMaybe<Scalars["ID"]["input"]>;
  /** not in: [x, y ….] */
  nin?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

/** Autogenerated input type of UpdateGroup. */
export type UpdateGroupInput = {
  baseRoleID?: InputMaybe<Scalars["ID"]["input"]>;
  code?: InputMaybe<Scalars["String"]["input"]>;
  id: Scalars["ID"]["input"];
  name?: InputMaybe<Scalars["String"]["input"]>;
  representativeRoleID?: InputMaybe<Scalars["ID"]["input"]>;
};

export type UpdateOrganizationInput = {
  id: Scalars["ID"]["input"];
  name?: InputMaybe<Scalars["String"]["input"]>;
  rootGroupId?: InputMaybe<Scalars["ID"]["input"]>;
};

export type UpdatePolicyInput = {
  actions?: InputMaybe<Array<Scalars["String"]["input"]>>;
  condition?: InputMaybe<ConditionInput>;
  id: Scalars["ID"]["input"];
  passwordRule?: InputMaybe<Scalars["Int"]["input"]>;
  permit?: InputMaybe<Permit>;
  resources?: InputMaybe<Array<Scalars["String"]["input"]>>;
  roleID?: InputMaybe<Scalars["ID"]["input"]>;
  serviceID?: InputMaybe<Scalars["ID"]["input"]>;
};

export type UpdateRoleClassInput = {
  id: Scalars["ID"]["input"];
  name?: InputMaybe<Scalars["String"]["input"]>;
};

export type UpdateRoleInput = {
  id: Scalars["ID"]["input"];
  name?: InputMaybe<Scalars["String"]["input"]>;
  roleClassID?: InputMaybe<Scalars["ID"]["input"]>;
};

export type UpdateServiceInput = {
  id: Scalars["ID"]["input"];
  name?: InputMaybe<Scalars["String"]["input"]>;
  url?: InputMaybe<Scalars["String"]["input"]>;
};

export type UpdateUserGroupResult = {
  added?: Maybe<Array<Scalars["ID"]["output"]>>;
  deleted?: Maybe<Array<Scalars["ID"]["output"]>>;
};

export type UpdateUserInput = {
  displayName?: InputMaybe<Scalars["String"]["input"]>;
  groups?: InputMaybe<Array<InputMaybe<GroupInput>>>;
  id: Scalars["ID"]["input"];
  profile?: InputMaybe<CreateUserProfileInput>;
  roles?: InputMaybe<Array<InputMaybe<RoleInput>>>;
  username?: InputMaybe<Scalars["String"]["input"]>;
};

export type UpdateUserRoleResult = {
  added?: Maybe<Array<Scalars["ID"]["output"]>>;
  deleted?: Maybe<Array<Scalars["ID"]["output"]>>;
};

export type UpdateUserTypeInput = {
  id: Scalars["ID"]["input"];
  name?: InputMaybe<Scalars["String"]["input"]>;
};

export type User = {
  /** The timestamp of when the user was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The timestamp of when the user was soft-deleted (if applicable). */
  deletedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The name that is displayed to other users in the application. */
  displayName: Scalars["String"]["output"];
  /** A list of groups that the user belongs to. */
  groups: Array<Group>;
  /** The ID for the user. */
  id: Scalars["ID"]["output"];
  /** The timestamp of the user's most recent login. */
  lastLoggedInAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The ID of the organization that the user belongs to. */
  organizationID: Scalars["ID"]["output"];
  /** A collection of data that represents the user's profile information. */
  profile?: Maybe<UserProfile>;
  /** A list of roles that the user belongs to, indicating the permissions they have in the application. */
  roles: Array<Role>;
  /** The timestamp of when the user was last updated. */
  updatedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** A list of user groups that the user belongs to. */
  userGroups: Array<UserGroup>;
  /** A list of user roles that the user has been assigned. */
  userRoles: Array<UserRole>;
  /** The username used by the user to log in. */
  username: Scalars["String"]["output"];
};

/** A list of User. */
export type UserCollection = {
  /** Information to aid in pagination. */
  collection: Array<User>;
  /** Information to aid in pagination. */
  from: Scalars["Int"]["output"];
  /** Information to aid in pagination. */
  size: Scalars["Int"]["output"];
  /** Information to aid in pagination. */
  total: Scalars["Int"]["output"];
};

export type UserFilterConditionalInputType = {
  /** and condition */
  and?: InputMaybe<Array<InputMaybe<UserQueryInput>>>;
  /** or condition */
  or?: InputMaybe<Array<InputMaybe<UserQueryInput>>>;
};

export type UserGroup = {
  createdAt?: Maybe<Scalars["DateTime"]["output"]>;
  endAt?: Maybe<Scalars["DateTime"]["output"]>;
  group?: Maybe<Group>;
  id?: Maybe<Scalars["ID"]["output"]>;
  startAt?: Maybe<Scalars["DateTime"]["output"]>;
};

/** Autogenerated input type of UserGroupUpdate. */
export type UserGroupAddInput = {
  endAt?: InputMaybe<Scalars["DateTime"]["input"]>;
  groupID: Scalars["ID"]["input"];
  startAt?: InputMaybe<Scalars["DateTime"]["input"]>;
  userID: Scalars["ID"]["input"];
};

export type UserGroupDeleteInput = {
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of UserGroup. */
export type UserGroupInput = {
  groupID: Scalars["ID"]["input"];
  userID?: InputMaybe<Array<InputMaybe<UserInput>>>;
};

export type UserInput = {
  id: Scalars["ID"]["input"];
};

export const UserOrderFieldEnum = {
  CreatedAt: "CREATED_AT",
  DisplayName: "DISPLAY_NAME",
  LastLoggedInAt: "LAST_LOGGED_IN_AT",
  UpdatedAt: "UPDATED_AT",
  Username: "USERNAME",
} as const;

export type UserOrderFieldEnum =
  (typeof UserOrderFieldEnum)[keyof typeof UserOrderFieldEnum];
export type UserOrderInput = {
  direction?: InputMaybe<OrderDirectionEnum>;
  field: UserOrderFieldEnum;
};

/** A user profile object that contains personal and contact information of a user. */
export type UserProfile = {
  /** The birthday of the user. */
  birthday?: Maybe<Scalars["DateTime"]["output"]>;
  /** The city of the user. */
  city?: Maybe<Scalars["String"]["output"]>;
  /** The cost center of the user. */
  costCenter?: Maybe<Scalars["String"]["output"]>;
  /** The country code of the user. */
  countryCode?: Maybe<Scalars["String"]["output"]>;
  /** The date and time the user profile was created. */
  createdAt: Scalars["DateTime"]["output"];
  /** The department of the user. */
  department?: Maybe<Scalars["String"]["output"]>;
  /** The display name of the user. */
  displayName?: Maybe<Scalars["String"]["output"]>;
  /** The division of the user. */
  division?: Maybe<Scalars["String"]["output"]>;
  /** The email address of the user. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The employee code of the user. */
  employeeCode?: Maybe<Scalars["String"]["output"]>;
  /** The first name of the user. */
  firstName?: Maybe<Scalars["String"]["output"]>;
  /** The gender of the user. */
  gender?: Maybe<Gender>;
  /** The honorific prefix of the user. */
  honorificPrefix?: Maybe<Scalars["String"]["output"]>;
  /** The honorific suffix of the user. */
  honorificSuffix?: Maybe<Scalars["String"]["output"]>;
  /** The ID for the user profile. */
  id: Scalars["ID"]["output"];
  /** The date the user joined the organization. */
  joinedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The last name of the user. */
  lastName?: Maybe<Scalars["String"]["output"]>;
  /** The date the user left the organization. */
  leftAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The locale of the user. */
  locale?: Maybe<Scalars["String"]["output"]>;
  /** The middle name of the user. */
  middleName?: Maybe<Scalars["String"]["output"]>;
  /** The mobile phone number of the user. */
  mobilePhone?: Maybe<Scalars["String"]["output"]>;
  /** The nickname of the user. */
  nickName?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the organization that the user belongs to. */
  organizationID?: Maybe<Scalars["ID"]["output"]>;
  /** The preferred language of the user. */
  preferredLanguage?: Maybe<Scalars["String"]["output"]>;
  /** The primary phone number of the user. */
  primaryPhone?: Maybe<Scalars["String"]["output"]>;
  /** The URL of the user's profile. */
  profileUrl?: Maybe<Scalars["String"]["output"]>;
  /** The secondary email address of the user. */
  secondEmail?: Maybe<Scalars["String"]["output"]>;
  /** The state of the user. */
  state?: Maybe<Scalars["String"]["output"]>;
  /** The street address of the user. */
  streetAddress?: Maybe<Scalars["String"]["output"]>;
  /** The timezone of the user. */
  timezone?: Maybe<Scalars["String"]["output"]>;
  /** The title of the user. */
  title?: Maybe<Scalars["String"]["output"]>;
  /** The date and time the user profile was last updated. */
  updatedAt?: Maybe<Scalars["DateTime"]["output"]>;
  /** The type of the user. */
  userType?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the user type. */
  userTypeId?: Maybe<Scalars["ID"]["output"]>;
  /** The username of the user. */
  username?: Maybe<Scalars["String"]["output"]>;
  /** The ZIP code of the user. */
  zipCode?: Maybe<Scalars["String"]["output"]>;
};

/** A collection to a list of items. */
export type UserProfileCollection = {
  /** Information to aid in pagination. */
  collection: Array<UserProfile>;
  from: Scalars["Int"]["output"];
  size: Scalars["Int"]["output"];
  /** Information to aid in pagination. */
  total: Scalars["Int"]["output"];
};

export type UserProfileFilterConditionalInputType = {
  /** and condition */
  and?: InputMaybe<Array<InputMaybe<UserProfileQueryInput>>>;
  /** or condition */
  or?: InputMaybe<Array<InputMaybe<UserProfileQueryInput>>>;
};

export const UserProfileOrderFieldEnum = {
  Birthday: "BIRTHDAY",
  City: "CITY",
  CostCenter: "COST_CENTER",
  CountryCode: "COUNTRY_CODE",
  CreatedAt: "CREATED_AT",
  Department: "DEPARTMENT",
  Division: "DIVISION",
  Email: "EMAIL",
  EmployeeCode: "EMPLOYEE_CODE",
  FirstName: "FIRST_NAME",
  Gender: "GENDER",
  HonorificPrefix: "HONORIFIC_PREFIX",
  HonorificSuffix: "HONORIFIC_SUFFIX",
  JoinedAt: "JOINED_AT",
  LastName: "LAST_NAME",
  LeftAt: "LEFT_AT",
  Locale: "LOCALE",
  MiddleName: "MIDDLE_NAME",
  ModulePhone: "MODULE_PHONE",
  NickName: "NICK_NAME",
  PreferredLanguage: "PREFERRED_LANGUAGE",
  PrimaryPhone: "PRIMARY_PHONE",
  ProfileUrl: "PROFILE_URL",
  SecondEmail: "SECOND_EMAIL",
  State: "STATE",
  StreetAddress: "STREET_ADDRESS",
  Timezone: "TIMEZONE",
  Title: "TITLE",
  UpdatedAt: "UPDATED_AT",
  ZipCode: "ZIP_CODE",
} as const;

export type UserProfileOrderFieldEnum =
  (typeof UserProfileOrderFieldEnum)[keyof typeof UserProfileOrderFieldEnum];
export type UserProfileOrderInput = {
  direction?: InputMaybe<OrderDirectionEnum>;
  field: UserProfileOrderFieldEnum;
};

export type UserProfileQueryInput = {
  /** and condition */
  and?: InputMaybe<UserProfileQueryInput>;
  birthday?: InputMaybe<DateTimeQueryInput>;
  city?: InputMaybe<StringQueryInput>;
  costCenter?: InputMaybe<StringQueryInput>;
  countryCode?: InputMaybe<StringQueryInput>;
  createdAt?: InputMaybe<DateTimeQueryInput>;
  deletedAt?: InputMaybe<DateTimeQueryInput>;
  department?: InputMaybe<StringQueryInput>;
  division?: InputMaybe<StringQueryInput>;
  email?: InputMaybe<StringQueryInput>;
  employeeCode?: InputMaybe<StringQueryInput>;
  firstName?: InputMaybe<StringQueryInput>;
  honorificPrefix?: InputMaybe<StringQueryInput>;
  honorificSuffix?: InputMaybe<StringQueryInput>;
  joinedAt?: InputMaybe<DateTimeQueryInput>;
  lastName?: InputMaybe<StringQueryInput>;
  leftAt?: InputMaybe<DateTimeQueryInput>;
  locale?: InputMaybe<StringQueryInput>;
  middleName?: InputMaybe<StringQueryInput>;
  mobilePhone?: InputMaybe<StringQueryInput>;
  nickName?: InputMaybe<StringQueryInput>;
  /** or condition */
  or?: InputMaybe<UserProfileQueryInput>;
  preferredLanguage?: InputMaybe<StringQueryInput>;
  primaryPhone?: InputMaybe<StringQueryInput>;
  profileUrl?: InputMaybe<StringQueryInput>;
  secondEmail?: InputMaybe<StringQueryInput>;
  state?: InputMaybe<StringQueryInput>;
  streetAddress?: InputMaybe<StringQueryInput>;
  timezone?: InputMaybe<StringQueryInput>;
  title?: InputMaybe<StringQueryInput>;
  updatedAt?: InputMaybe<DateTimeQueryInput>;
  userID?: InputMaybe<UuidQueryInput>;
  userTypeId?: InputMaybe<UuidQueryInput>;
  zipCode?: InputMaybe<StringQueryInput>;
};

export type UserQueryInput = {
  /** and condition */
  and?: InputMaybe<UserQueryInput>;
  createdAt?: InputMaybe<DateTimeQueryInput>;
  displayName?: InputMaybe<StringQueryInput>;
  id?: InputMaybe<UuidQueryInput>;
  lastLoggedInAt?: InputMaybe<DateTimeQueryInput>;
  /** or condition */
  or?: InputMaybe<UserQueryInput>;
  organizationID?: InputMaybe<UuidQueryInput>;
  roleID?: InputMaybe<UuidQueryInput>;
  updatedAt?: InputMaybe<DateTimeQueryInput>;
  username?: InputMaybe<StringQueryInput>;
};

export type UserRole = {
  createdAt?: Maybe<Scalars["DateTime"]["output"]>;
  endAt?: Maybe<Scalars["DateTime"]["output"]>;
  id?: Maybe<Scalars["ID"]["output"]>;
  role?: Maybe<Role>;
  startAt?: Maybe<Scalars["DateTime"]["output"]>;
};

export type UserRoleAddInput = {
  endAt?: InputMaybe<Scalars["DateTime"]["input"]>;
  roleID: Scalars["ID"]["input"];
  startAt?: InputMaybe<Scalars["DateTime"]["input"]>;
  userID: Scalars["ID"]["input"];
};

export type UserRoleDeleteInput = {
  id: Scalars["ID"]["input"];
};

export type UserRoleInput = {
  role?: InputMaybe<RoleInput>;
  user?: InputMaybe<UserInput>;
};

/** UserType. */
export type UserType = {
  id: Scalars["ID"]["output"];
  name?: Maybe<Scalars["String"]["output"]>;
  organizationID?: Maybe<Scalars["ID"]["output"]>;
};

/** A collection of UserType. */
export type UserTypeCollection = {
  /** Information to aid in pagination. */
  collection?: Maybe<Array<Maybe<UserType>>>;
  from?: Maybe<Scalars["Int"]["output"]>;
  size?: Maybe<Scalars["Int"]["output"]>;
  /** Information to aid in pagination. */
  total?: Maybe<Scalars["Int"]["output"]>;
};

export type UserTypeFilterConditionalInputType = {
  /** and condition */
  and?: InputMaybe<Array<InputMaybe<UserTypeQueryInput>>>;
  /** or condition */
  or?: InputMaybe<Array<InputMaybe<UserTypeQueryInput>>>;
};

export const UserTypeOrderFieldEnum = {
  CreatedAt: "CREATED_AT",
  Name: "NAME",
  UpdatedAt: "UPDATED_AT",
} as const;

export type UserTypeOrderFieldEnum =
  (typeof UserTypeOrderFieldEnum)[keyof typeof UserTypeOrderFieldEnum];
export type UserTypeOrderInput = {
  direction?: InputMaybe<OrderDirectionEnum>;
  field: UserTypeOrderFieldEnum;
};

export type UserTypeQueryInput = {
  /** and condition */
  and?: InputMaybe<UserTypeQueryInput>;
  name?: InputMaybe<StringQueryInput>;
  /** or condition */
  or?: InputMaybe<UserTypeQueryInput>;
  organizationID?: InputMaybe<UuidQueryInput>;
};

export type _Service = {
  sdl?: Maybe<Scalars["String"]["output"]>;
};
